# Class: Socket
**Inherits:** BasicSocket
    

Class `Socket` provides access to the underlying operating system socket
implementations.  It can be used to provide more operating system specific
functionality than the protocol-specific socket classes.

The constants defined under Socket::Constants are also defined under Socket. 
For example, Socket::AF_INET is usable as well as Socket::Constants::AF_INET. 
See Socket::Constants for the list of constants.

### What's a socket?

Sockets are endpoints of a bidirectional communication channel. Sockets can
communicate within a process, between processes on the same machine or between
different machines.  There are many types of socket: TCPSocket, UDPSocket or
UNIXSocket for example.

Sockets have their own vocabulary:

**domain:** The family of protocols:
*   Socket::PF_INET
*   Socket::PF_INET6
*   Socket::PF_UNIX
*   etc.

**type:** The type of communications between the two endpoints, typically
*   Socket::SOCK_STREAM
*   Socket::SOCK_DGRAM.

**protocol:** Typically *zero*. This may be used to identify a variant of a
protocol.

**hostname:** The identifier of a network interface:
*   a string (hostname, IPv4 or IPv6 address or `broadcast`
    which specifies a broadcast address)

*   a zero-length string which specifies INADDR_ANY
*   an integer (interpreted as binary address in host byte order).

### Quick start

Many of the classes, such as TCPSocket, UDPSocket or UNIXSocket, ease the use
of sockets comparatively to the equivalent C programming interface.

Let's create an internet socket using the IPv4 protocol in a C-like manner:

    require 'socket'

    s = Socket.new Socket::AF_INET, Socket::SOCK_STREAM
    s.connect Socket.pack_sockaddr_in(80, 'example.com')

You could also use the TCPSocket class:

    s = TCPSocket.new 'example.com', 80

A simple server might look like this:

    require 'socket'

    server = TCPServer.new 2000 # Server bound to port 2000

    loop do
      client = server.accept    # Wait for a client to connect
      client.puts "Hello !"
      client.puts "Time is #{Time.now}"
      client.close
    end

A simple client may look like this:

    require 'socket'

    s = TCPSocket.new 'localhost', 2000

    while line = s.gets # Read lines from socket
      puts line         # and print them
    end

    s.close             # close socket when done

### Exception Handling

Ruby's Socket implementation raises exceptions based on the error generated by
the system dependent implementation.  This is why the methods are documented
in a way that isolate Unix-based system exceptions from Windows based
exceptions. If more information on a particular exception is needed, please
refer to the Unix manual pages or the Windows WinSock reference.

### Convenience methods

Although the general way to create socket is Socket.new, there are several
methods of socket creation for most cases.

TCP client socket
:   Socket.tcp, TCPSocket.open

TCP server socket
:   Socket.tcp_server_loop, TCPServer.open

UNIX client socket
:   Socket.unix, UNIXSocket.open

UNIX server socket
:   Socket.unix_server_loop, UNIXServer.open


### Documentation by

*   Zach Dennis
*   Sam Roberts
*   *Programming Ruby* from The Pragmatic Bookshelf.

Much material in this documentation is taken with permission from *Programming
Ruby* from The Pragmatic Bookshelf.


# Class Methods
## accept_loop(*sockets ) [](#method-c-accept_loop)
yield socket and client address for each a connection accepted via given
sockets.

The arguments are a list of sockets. The individual argument should be a
socket or an array of sockets.

This method yields the block sequentially. It means that the next connection
is not accepted until the block returns. So concurrent mechanism, thread for
example, should be used to service multiple clients at a time.
## getaddrinfo(*args ) [](#method-c-getaddrinfo)
Obtains address information for *nodename*:*servname*.

Note that Addrinfo.getaddrinfo provides the same functionality in an object
oriented style.

*family* should be an address family such as: :INET, :INET6, etc.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* should be a protocol defined in the family, and defaults to 0 for
the family.

*flags* should be bitwise OR of Socket::AI_* constants.

    Socket.getaddrinfo("www.ruby-lang.org", "http", nil, :STREAM)
    #=> [["AF_INET", 80, "carbon.ruby-lang.org", "221.186.184.68", 2, 1, 6]] # PF_INET/SOCK_STREAM/IPPROTO_TCP

    Socket.getaddrinfo("localhost", nil)
    #=> [["AF_INET", 0, "localhost", "127.0.0.1", 2, 1, 6],  # PF_INET/SOCK_STREAM/IPPROTO_TCP
    #    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 2, 17], # PF_INET/SOCK_DGRAM/IPPROTO_UDP
    #    ["AF_INET", 0, "localhost", "127.0.0.1", 2, 3, 0]]  # PF_INET/SOCK_RAW/IPPROTO_IP

*reverse_lookup* directs the form of the third element, and has to be one of
below.  If *reverse_lookup* is omitted, the default value is `nil`.

    +true+, +:hostname+:  hostname is obtained from numeric address using reverse lookup, which may take a time.
    +false+, +:numeric+:  hostname is the same as numeric address.
    +nil+:              obey to the current +do_not_reverse_lookup+ flag.

If Addrinfo object is preferred, use Addrinfo.getaddrinfo.
**@overload** [] 

## gethostbyaddr(*args ) [](#method-c-gethostbyaddr)
Use Addrinfo#getnameinfo instead. This method is deprecated for the following
reasons:

*   Uncommon address representation: 4/16-bytes binary string to represent
    IPv4/IPv6 address.
*   gethostbyaddr() may take a long time and it may block other threads. (GVL
    cannot be released since gethostbyname() is not thread safe.)
*   This method uses gethostbyname() function already removed from POSIX.

This method obtains the host information for *address*.

    p Socket.gethostbyaddr([221,186,184,68].pack("CCCC"))
    #=> ["carbon.ruby-lang.org", [], 2, "\xDD\xBA\xB8D"]

    p Socket.gethostbyaddr([127,0,0,1].pack("CCCC"))
    ["localhost", [], 2, "\x7F\x00\x00\x01"]
    p Socket.gethostbyaddr(([0]*15+[1]).pack("C"*16))
    #=> ["localhost", ["ip6-localhost", "ip6-loopback"], 10,
         "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01"]
**@overload** [] 

## gethostbyname(host ) [](#method-c-gethostbyname)
Use Addrinfo.getaddrinfo instead. This method is deprecated for the following
reasons:

*   The 3rd element of the result is the address family of the first address.
    The address families of the rest of the addresses are not returned.
*   Uncommon address representation: 4/16-bytes binary string to represent
    IPv4/IPv6 address.
*   gethostbyname() may take a long time and it may block other threads. (GVL
    cannot be released since gethostbyname() is not thread safe.)
*   This method uses gethostbyname() function already removed from POSIX.

This method obtains the host information for *hostname*.

    p Socket.gethostbyname("hal") #=> ["localhost", ["hal"], 2, "\x7F\x00\x00\x01"]
**@overload** [] 

## gethostname() [](#method-c-gethostname)
## getifaddrs() [](#method-c-getifaddrs)
Returns an array of interface addresses. An element of the array is an
instance of Socket::Ifaddr.

This method can be used to find multicast-enabled interfaces:

    pp Socket.getifaddrs.reject {|ifaddr|
      !ifaddr.addr.ip? || (ifaddr.flags & Socket::IFF_MULTICAST == 0)
    }.map {|ifaddr| [ifaddr.name, ifaddr.ifindex, ifaddr.addr] }
    #=> [["eth0", 2, #<Addrinfo: 221.186.184.67>],
    #    ["eth0", 2, #<Addrinfo: fe80::216:3eff:fe95:88bb%eth0>]]

Example result on GNU/Linux:
    pp Socket.getifaddrs
    #=> [#<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 PACKET[protocol=0 lo hatype=772 HOST hwaddr=00:00:00:00:00:00]>,
    #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=00:16:3e:95:88:bb] broadcast=PACKET[protocol=0 eth0 hatype=1 HOST hwaddr=ff:ff:ff:ff:ff:ff]>,
    #    #<Socket::Ifaddr sit0 NOARP PACKET[protocol=0 sit0 hatype=776 HOST hwaddr=00:00:00:00]>,
    #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 127.0.0.1 netmask=255.0.0.0>,
    #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 221.186.184.67 netmask=255.255.255.240 broadcast=221.186.184.79>,
    #    #<Socket::Ifaddr lo UP,LOOPBACK,RUNNING,0x10000 ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,
    #    #<Socket::Ifaddr eth0 UP,BROADCAST,RUNNING,MULTICAST,0x10000 fe80::216:3eff:fe95:88bb%eth0 netmask=ffff:ffff:ffff:ffff::>]

Example result on FreeBSD:
    pp Socket.getifaddrs
    #=> [#<Socket::Ifaddr usbus0 UP,0x10000 LINK[usbus0]>,
    #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 LINK[re0 3a:d0:40:9a:fe:e8]>,
    #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 10.250.10.18 netmask=255.255.255.? (7 bytes for 16 bytes sockaddr_in) broadcast=10.250.10.255>,
    #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 fe80:2::38d0:40ff:fe9a:fee8 netmask=ffff:ffff:ffff:ffff::>,
    #    #<Socket::Ifaddr re0 UP,BROADCAST,RUNNING,MULTICAST,0x800 2001:2e8:408:10::12 netmask=UNSPEC>,
    #    #<Socket::Ifaddr plip0 POINTOPOINT,MULTICAST,0x800 LINK[plip0]>,
    #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST LINK[lo0]>,
    #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST ::1 netmask=ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>,
    #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST fe80:4::1 netmask=ffff:ffff:ffff:ffff::>,
    #    #<Socket::Ifaddr lo0 UP,LOOPBACK,RUNNING,MULTICAST 127.0.0.1 netmask=255.?.?.? (5 bytes for 16 bytes sockaddr_in)>]
**@overload** [] 

## getnameinfo(*args ) [](#method-c-getnameinfo)
Obtains name information for *sockaddr*.

*sockaddr* should be one of follows.
*   packed sockaddr string such as Socket.sockaddr_in(80, "127.0.0.1")
*   3-elements array such as ["AF_INET", 80, "127.0.0.1"]
*   4-elements array such as ["AF_INET", 80, ignored, "127.0.0.1"]

*flags* should be bitwise OR of Socket::NI_* constants.

Note: The last form is compatible with IPSocket#addr and IPSocket#peeraddr.

    Socket.getnameinfo(Socket.sockaddr_in(80, "127.0.0.1"))       #=> ["localhost", "www"]
    Socket.getnameinfo(["AF_INET", 80, "127.0.0.1"])              #=> ["localhost", "www"]
    Socket.getnameinfo(["AF_INET", 80, "localhost", "127.0.0.1"]) #=> ["localhost", "www"]

If Addrinfo object is preferred, use Addrinfo#getnameinfo.
**@overload** [] 

## getservbyname(*args ) [](#method-c-getservbyname)
Obtains the port number for *service_name*.

If *protocol_name* is not given, "tcp" is assumed.

    Socket.getservbyname("smtp")          #=> 25
    Socket.getservbyname("shell")         #=> 514
    Socket.getservbyname("syslog", "udp") #=> 514
**@overload** [] 

**@overload** [] 

## getservbyport(*args ) [](#method-c-getservbyport)
Obtains the port number for *port*.

If *protocol_name* is not given, "tcp" is assumed.

    Socket.getservbyport(80)         #=> "www"
    Socket.getservbyport(514, "tcp") #=> "shell"
    Socket.getservbyport(514, "udp") #=> "syslog"
**@overload** [] 

## ip_address_list() [](#method-c-ip_address_list)
Returns local IP addresses as an array.

The array contains Addrinfo objects.

    pp Socket.ip_address_list
    #=> [#<Addrinfo: 127.0.0.1>,
         #<Addrinfo: 192.168.0.128>,
         #<Addrinfo: ::1>,
         ...]
**@overload** [] 

## ip_sockets_port0(ai_list , reuseaddr ) [](#method-c-ip_sockets_port0)
:stopdoc:
## pack_sockaddr_in(port , host ) [](#method-c-pack_sockaddr_in)
Packs *port* and *host* as an AF_INET/AF_INET6 sockaddr string.

    Socket.sockaddr_in(80, "127.0.0.1")
    #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"

    Socket.sockaddr_in(80, "::1")
    #=> "\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"
**@overload** [] 

**@overload** [] 

## pack_sockaddr_un(path ) [](#method-c-pack_sockaddr_un)
Packs *path* as an AF_UNIX sockaddr string.

    Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."
**@overload** [] 

**@overload** [] 

## pair(*args ) [](#method-c-pair)
Creates a pair of sockets connected each other.

*domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* should be a protocol defined in the domain, defaults to 0 for the
domain.

    s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
    s1.send "a", 0
    s1.send "b", 0
    s1.close
    p s2.recv(10) #=> "ab"
    p s2.recv(10) #=> ""
    p s2.recv(10) #=> ""

    s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
    s1.send "a", 0
    s1.send "b", 0
    p s2.recv(10) #=> "a"
    p s2.recv(10) #=> "b"
**@overload** [] 

**@overload** [] 

## sockaddr_in(port , host ) [](#method-c-sockaddr_in)
Packs *port* and *host* as an AF_INET/AF_INET6 sockaddr string.

    Socket.sockaddr_in(80, "127.0.0.1")
    #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"

    Socket.sockaddr_in(80, "::1")
    #=> "\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00"
**@overload** [] 

**@overload** [] 

## sockaddr_un(path ) [](#method-c-sockaddr_un)
Packs *path* as an AF_UNIX sockaddr string.

    Socket.sockaddr_un("/tmp/sock") #=> "\x01\x00/tmp/sock\x00\x00..."
**@overload** [] 

**@overload** [] 

## socketpair(*args ) [](#method-c-socketpair)
Creates a pair of sockets connected each other.

*domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* should be a protocol defined in the domain, defaults to 0 for the
domain.

    s1, s2 = Socket.pair(:UNIX, :STREAM, 0)
    s1.send "a", 0
    s1.send "b", 0
    s1.close
    p s2.recv(10) #=> "ab"
    p s2.recv(10) #=> ""
    p s2.recv(10) #=> ""

    s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)
    s1.send "a", 0
    s1.send "b", 0
    p s2.recv(10) #=> "a"
    p s2.recv(10) #=> "b"
**@overload** [] 

**@overload** [] 

## tcp(host , port , local_host nil, local_port nil, connect_timeout: nil, resolv_timeout: nil, fast_fallback: tcp_fast_fallback) [](#method-c-tcp)
:call-seq:
    Socket.tcp(host, port, local_host=nil, local_port=nil, [opts]) {|socket| ... }
    Socket.tcp(host, port, local_host=nil, local_port=nil, [opts])

creates a new socket object connected to host:port using TCP/IP.

Starting from Ruby 3.4, this method operates according to the Happy Eyeballs
Version 2 ([RFC 8305](https://datatracker.ietf.org/doc/html/rfc8305))
algorithm by default.

For details on Happy Eyeballs Version 2, see
[Socket.tcp_fast_fallback=](rdoc-ref:Socket.tcp_fast_fallback=).

To make it behave the same as in Ruby 3.3 and earlier, explicitly specify the
option fast_fallback:false. Or, setting Socket.tcp_fast_fallback=false will
disable Happy Eyeballs Version 2 not only for this method but for all Socket
globally.

If local_host:local_port is given, the socket is bound to it.

The optional last argument *opts* is options represented by a hash. *opts* may
have following options:

:resolv_timeout
:   Specifies the timeout in seconds from when the hostname resolution starts.

:connect_timeout
:   This method sequentially attempts connecting to all candidate destination
    addresses.  
    The `connect_timeout` specifies the timeout in seconds from the start of
    the connection attempt to the last candidate.  
    By default, all connection attempts continue until the timeout occurs.  
    When `fast_fallback:false` is explicitly specified,  
    a timeout is set for each connection attempt and any connection attempt
    that exceeds its timeout will be canceled.

:fast_fallback
:   Enables the Happy Eyeballs Version 2 algorithm (enabled by default).


If a block is given, the block is called with the socket. The value of the
block is returned. The socket is closed when this method returns.

If no block is given, the socket is returned.

    Socket.tcp("www.ruby-lang.org", 80) {|sock|
      sock.print "GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n"
      sock.close_write
      puts sock.read
    }
## tcp_fast_fallback() [](#method-c-tcp_fast_fallback)
Returns whether Happy Eyeballs Version 2 ([RFC
8305](https://datatracker.ietf.org/doc/html/rfc8305)), which is provided
starting from Ruby 3.4 when using TCPSocket.new and Socket.tcp, is enabled or
disabled.

If true, it is enabled for TCPSocket.new and Socket.tcp. (Note: Happy Eyeballs
Version 2 is not provided when using TCPSocket.new on Windows.)

If false, Happy Eyeballs Version 2 is disabled.

For details on Happy Eyeballs Version 2, see
[Socket.tcp_fast_fallback=](rdoc-ref:Socket.tcp_fast_fallback=).
**@overload** [] 

## tcp_fast_fallback=(value ) [](#method-c-tcp_fast_fallback=)
Enable or disable Happy Eyeballs Version 2 ([RFC
8305](https://datatracker.ietf.org/doc/html/rfc8305)) globally, which is
provided starting from Ruby 3.4 when using TCPSocket.new and Socket.tcp.

When set to true, the feature is enabled for both `TCPSocket.new` and
`Socket.tcp`. (Note: This feature is not available when using TCPSocket.new on
Windows.)

When set to false, the behavior reverts to that of Ruby 3.3 or earlier.

The default value is true if no value is explicitly set by calling this
method. However, when the environment variable RUBY_TCP_NO_FAST_FALLBACK=1 is
set, the default is false.

To control the setting on a per-method basis, use the fast_fallback keyword
argument for each method.

### Happy Eyeballs Version 2
Happy Eyeballs Version 2 ([RFC
8305](https://datatracker.ietf.org/doc/html/rfc8305)) is an algorithm designed
to improve client socket connectivity.  
 It aims for more reliable and efficient connections by performing hostname
resolution and connection attempts in parallel, instead of serially.

Starting from Ruby 3.4, this method operates as follows with this algorithm:

1.  Start resolving both IPv6 and IPv4 addresses concurrently.
2.  Start connecting to the one of the addresses that are obtained first.  
    If IPv4 addresses are obtained first, the method waits 50 ms for IPv6 name
    resolution to prioritize IPv6 connections.
3.  After starting a connection attempt, wait 250 ms for the connection to be
    established.  
     If no connection is established within this time, a new connection is
    started every 250 ms  
     until a connection is  established or there are no more candidate
    addresses.  
     (Although RFC 8305 strictly specifies sorting addresses,  
     this method only alternates between IPv6 / IPv4 addresses due to the
    performance concerns)
4.  Once a connection is established, all remaining connection attempts are
    canceled.
**@overload** [] 

## tcp_server_loop(host nil, port , &b ) [](#method-c-tcp_server_loop)
creates a TCP/IP server on *port* and calls the block for each connection
accepted. The block is called with a socket and a client_address as an
Addrinfo object.

If *host* is specified, it is used with *port* to determine the server
addresses.

The socket is **not** closed when the block returns. So application should
close it explicitly.

This method calls the block sequentially. It means that the next connection is
not accepted until the block returns. So concurrent mechanism, thread for
example, should be used to service multiple clients at a time.

Note that Addrinfo.getaddrinfo is used to determine the server socket
addresses. When Addrinfo.getaddrinfo returns two or more addresses, IPv4 and
IPv6 address for example, all of them are used. Socket.tcp_server_loop
succeeds if one socket can be used at least.

    # Sequential echo server.
    # It services only one client at a time.
    Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
      begin
        IO.copy_stream(sock, sock)
      ensure
        sock.close
      end
    }

    # Threaded echo server
    # It services multiple clients at a time.
    # Note that it may accept connections too much.
    Socket.tcp_server_loop(16807) {|sock, client_addrinfo|
      Thread.new {
        begin
          IO.copy_stream(sock, sock)
        ensure
          sock.close
        end
      }
    }
## tcp_server_sockets(host nil, port ) [](#method-c-tcp_server_sockets)
creates TCP/IP server sockets for *host* and *port*. *host* is optional.

If no block given, it returns an array of listening sockets.

If a block is given, the block is called with the sockets. The value of the
block is returned. The socket is closed when this method returns.

If *port* is 0, actual port number is chosen dynamically. However all sockets
in the result has same port number.

    # tcp_server_sockets returns two sockets.
    sockets = Socket.tcp_server_sockets(1296)
    p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]

    # The sockets contains IPv6 and IPv4 sockets.
    sockets.each {|s| p s.local_address }
    #=> #<Addrinfo: [::]:1296 TCP>
    #   #<Addrinfo: 0.0.0.0:1296 TCP>

    # IPv6 and IPv4 socket has same port number, 53114, even if it is chosen dynamically.
    sockets = Socket.tcp_server_sockets(0)
    sockets.each {|s| p s.local_address }
    #=> #<Addrinfo: [::]:53114 TCP>
    #   #<Addrinfo: 0.0.0.0:53114 TCP>

    # The block is called with the sockets.
    Socket.tcp_server_sockets(0) {|sockets|
      p sockets #=> [#<Socket:fd 3>, #<Socket:fd 4>]
    }
## tcp_server_sockets_port0(host ) [](#method-c-tcp_server_sockets_port0)
## tcp_with_fast_fallback(host , port , local_host nil, local_port nil, connect_timeout: nil, resolv_timeout: nil) [](#method-c-tcp_with_fast_fallback)
## udp_server_loop(host nil, port , &b ) [](#method-c-udp_server_loop)
:call-seq:
    Socket.udp_server_loop(port) {|msg, msg_src| ... }
    Socket.udp_server_loop(host, port) {|msg, msg_src| ... }

creates a UDP/IP server on *port* and calls the block for each message
arrived. The block is called with the message and its source information.

This method allocates sockets internally using *port*. If *host* is specified,
it is used conjunction with *port* to determine the server addresses.

The *msg* is a string.

The *msg_src* is a Socket::UDPSource object. It is used for reply.

    # UDP/IP echo server.
    Socket.udp_server_loop(9261) {|msg, msg_src|
      msg_src.reply msg
    }
## udp_server_loop_on(sockets , &b ) [](#method-c-udp_server_loop_on)
:call-seq:
    Socket.udp_server_loop_on(sockets) {|msg, msg_src| ... }

Run UDP/IP server loop on the given sockets.

The return value of Socket.udp_server_sockets is appropriate for the argument.

It calls the block for each message received.
## udp_server_recv(sockets ) [](#method-c-udp_server_recv)
:call-seq:
    Socket.udp_server_recv(sockets) {|msg, msg_src| ... }

Receive UDP/IP packets from the given *sockets*. For each packet received, the
block is called.

The block receives *msg* and *msg_src*. *msg* is a string which is the payload
of the received packet. *msg_src* is a Socket::UDPSource object which is used
for reply.

Socket.udp_server_loop can be implemented using this method as follows.

    udp_server_sockets(host, port) {|sockets|
      loop {
        readable, _, _ = IO.select(sockets)
        udp_server_recv(readable) {|msg, msg_src| ... }
      }
    }
## udp_server_sockets(host nil, port ) [](#method-c-udp_server_sockets)
:call-seq:
    Socket.udp_server_sockets([host, ] port)

Creates UDP/IP sockets for a UDP server.

If no block given, it returns an array of sockets.

If a block is given, the block is called with the sockets. The value of the
block is returned. The sockets are closed when this method returns.

If *port* is zero, some port is chosen. But the chosen port is used for the
all sockets.

    # UDP/IP echo server
    Socket.udp_server_sockets(0) {|sockets|
      p sockets.first.local_address.ip_port     #=> 32963
      Socket.udp_server_loop_on(sockets) {|msg, msg_src|
        msg_src.reply msg
      }
    }
## unix(path ) [](#method-c-unix)
creates a new socket connected to path using UNIX socket socket.

If a block is given, the block is called with the socket. The value of the
block is returned. The socket is closed when this method returns.

If no block is given, the socket is returned.

    # talk to /tmp/sock socket.
    Socket.unix("/tmp/sock") {|sock|
      t = Thread.new { IO.copy_stream(sock, STDOUT) }
      IO.copy_stream(STDIN, sock)
      t.join
    }
## unix_server_loop(path , &b ) [](#method-c-unix_server_loop)
creates a UNIX socket server on *path*. It calls the block for each socket
accepted.

If *host* is specified, it is used with *port* to determine the server ports.

The socket is **not** closed when the block returns. So application should
close it.

This method deletes the socket file pointed by *path* at first if the file is
a socket file and it is owned by the user of the application. This is safe
only if the directory of *path* is not changed by a malicious user. So don't
use /tmp/malicious-users-directory/socket. Note that /tmp/socket and
/tmp/your-private-directory/socket is safe assuming that /tmp has sticky bit.

    # Sequential echo server.
    # It services only one client at a time.
    Socket.unix_server_loop("/tmp/sock") {|sock, client_addrinfo|
      begin
        IO.copy_stream(sock, sock)
      ensure
        sock.close
      end
    }
## unix_server_socket(path ) [](#method-c-unix_server_socket)
creates a UNIX server socket on *path*

If no block given, it returns a listening socket.

If a block is given, it is called with the socket and the block value is
returned. When the block exits, the socket is closed and the socket file is
removed.

    socket = Socket.unix_server_socket("/tmp/s")
    p socket                  #=> #<Socket:fd 3>
    p socket.local_address    #=> #<Addrinfo: /tmp/s SOCK_STREAM>

    Socket.unix_server_socket("/tmp/sock") {|s|
      p s                     #=> #<Socket:fd 3>
      p s.local_address       #=> # #<Addrinfo: /tmp/sock SOCK_STREAM>
    }
## unpack_sockaddr_in(addr ) [](#method-c-unpack_sockaddr_in)
Unpacks *sockaddr* into port and ip_address.

*sockaddr* should be a string or an addrinfo for AF_INET/AF_INET6.

    sockaddr = Socket.sockaddr_in(80, "127.0.0.1")
    p sockaddr #=> "\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00"
    p Socket.unpack_sockaddr_in(sockaddr) #=> [80, "127.0.0.1"]
**@overload** [] 

## unpack_sockaddr_un(addr ) [](#method-c-unpack_sockaddr_un)
Unpacks *sockaddr* into path.

*sockaddr* should be a string or an addrinfo for AF_UNIX.

    sockaddr = Socket.sockaddr_un("/tmp/sock")
    p Socket.unpack_sockaddr_un(sockaddr) #=> "/tmp/sock"
**@overload** [] 


#Instance Methods
## accept() [](#method-i-accept)
Accepts a next connection. Returns a new Socket object and Addrinfo object.

    serv = Socket.new(:INET, :STREAM, 0)
    serv.listen(5)
    c = Socket.new(:INET, :STREAM, 0)
    c.connect(serv.connect_address)
    p serv.accept #=> [#<Socket:fd 6>, #<Addrinfo: 127.0.0.1:48555 TCP>]

**@overload** [] 

## accept_nonblock(exception:true) [](#method-i-accept_nonblock)
call-seq:
    socket.accept_nonblock([options]) => [client_socket, client_addrinfo]

Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the
underlying file descriptor. It returns an array containing the accepted socket
for the incoming connection, *client_socket*, and an Addrinfo,
*client_addrinfo*.

### Example
    # In one script, start this first
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(2200, 'localhost')
    socket.bind(sockaddr)
    socket.listen(5)
    begin # emulate blocking accept
      client_socket, client_addrinfo = socket.accept_nonblock
    rescue IO::WaitReadable, Errno::EINTR
      IO.select([socket])
      retry
    end
    puts "The client said, '#{client_socket.readline.chomp}'"
    client_socket.puts "Hello from script one!"
    socket.close

    # In another script, start this second
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(2200, 'localhost')
    socket.connect(sockaddr)
    socket.puts "Hello from script 2."
    puts "The server said, '#{socket.readline.chomp}'"
    socket.close

Refer to Socket#accept for the exceptions that may be thrown if the call to
*accept_nonblock* fails.

Socket#accept_nonblock may raise any error corresponding to accept(2) failure,
including Errno::EWOULDBLOCK.

If the exception is Errno::EWOULDBLOCK, Errno::EAGAIN, Errno::ECONNABORTED or
Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be
used to rescue the exceptions for retrying accept_nonblock.

By specifying a keyword argument *exception* to `false`, you can indicate that
accept_nonblock should not raise an IO::WaitReadable exception, but return the
symbol `:wait_readable` instead.

### See
*   Socket#accept

## bind(addr) [](#method-i-bind)
Binds to the given local address.

### Parameter
*   `local_sockaddr` - the `struct` sockaddr contained in a string or an
    Addrinfo object

### Example
    require 'socket'

    # use Addrinfo
    socket = Socket.new(:INET, :STREAM, 0)
    socket.bind(Addrinfo.tcp("127.0.0.1", 2222))
    p socket.local_address #=> #<Addrinfo: 127.0.0.1:2222 TCP>

    # use struct sockaddr
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )

### Unix-based Exceptions
On unix-based based systems the following system exceptions may be raised if
the call to *bind* fails:
*   Errno::EACCES - the specified *sockaddr* is protected and the current user
    does not have permission to bind to it
*   Errno::EADDRINUSE - the specified *sockaddr* is already in use
*   Errno::EADDRNOTAVAIL - the specified *sockaddr* is not available from the
    local machine
*   Errno::EAFNOSUPPORT - the specified *sockaddr* is not a valid address for
    the family of the calling `socket`
*   Errno::EBADF - the *sockaddr* specified is not a valid file descriptor
*   Errno::EFAULT - the *sockaddr* argument cannot be accessed
*   Errno::EINVAL - the `socket` is already bound to an address, and the
    protocol does not support binding to the new *sockaddr* or the `socket`
    has been shut down.
*   Errno::EINVAL - the address length is not a valid length for the address
    family
*   Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
    PATH_MAX
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOSR - there were insufficient STREAMS resources available to
    complete the operation
*   Errno::ENOTSOCK - the `socket` does not refer to a socket
*   Errno::EOPNOTSUPP - the socket type of the `socket` does not support
    binding to an address

On unix-based based systems if the address family of the calling `socket` is
Socket::AF_UNIX the follow exceptions may be raised if the call to *bind*
fails:
*   Errno::EACCES - search permission is denied for a component of the prefix
    path or write access to the `socket` is denied
*   Errno::EDESTADDRREQ - the *sockaddr* argument is a null pointer
*   Errno::EISDIR - same as Errno::EDESTADDRREQ
*   Errno::EIO - an i/o error occurred
*   Errno::ELOOP - too many symbolic links were encountered in translating the
    pathname in *sockaddr*
*   Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
    characters, or an entire pathname exceeded PATH_MAX characters
*   Errno::ENOENT - a component of the pathname does not name an existing file
    or the pathname is an empty string
*   Errno::ENOTDIR - a component of the path prefix of the pathname in
    *sockaddr* is not a directory
*   Errno::EROFS - the name would reside on a read only filesystem

### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *bind* fails:
*   Errno::ENETDOWN-- the network is down
*   Errno::EACCES - the attempt to connect the datagram socket to the
    broadcast address failed
*   Errno::EADDRINUSE - the socket's local address is already in use
*   Errno::EADDRNOTAVAIL - the specified address is not a valid address for
    this computer
*   Errno::EFAULT - the socket's internal address or address length parameter
    is too small or is not a valid part of the user space addressed
*   Errno::EINVAL - the `socket` is already bound to an address
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOTSOCK - the `socket` argument does not refer to a socket

### See
*   bind manual pages on unix-based systems
*   bind function in Microsoft's Winsock functions reference

**@overload** [] 

## connect(addr) [](#method-i-connect)
Requests a connection to be made on the given `remote_sockaddr`. Returns 0 if
successful, otherwise an exception is raised.

### Parameter
*   `remote_sockaddr` - the `struct` sockaddr contained in a string or
    Addrinfo object

### Example:
    # Pull down Google's web page
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 80, 'www.google.com' )
    socket.connect( sockaddr )
    socket.write( "GET / HTTP/1.0\r\n\r\n" )
    results = socket.read

### Unix-based Exceptions
On unix-based systems the following system exceptions may be raised if the
call to *connect* fails:
*   Errno::EACCES - search permission is denied for a component of the prefix
    path or write access to the `socket` is denied
*   Errno::EADDRINUSE - the *sockaddr* is already in use
*   Errno::EADDRNOTAVAIL - the specified *sockaddr* is not available from the
    local machine
*   Errno::EAFNOSUPPORT - the specified *sockaddr* is not a valid address for
    the address family of the specified `socket`
*   Errno::EALREADY - a connection is already in progress for the specified
    socket
*   Errno::EBADF - the `socket` is not a valid file descriptor
*   Errno::ECONNREFUSED - the target *sockaddr* was not listening for
    connections refused the connection request
*   Errno::ECONNRESET - the remote host reset the connection request
*   Errno::EFAULT - the *sockaddr* cannot be accessed
*   Errno::EHOSTUNREACH - the destination host cannot be reached (probably
    because the host is down or a remote router cannot reach it)
*   Errno::EINPROGRESS - the O_NONBLOCK is set for the `socket` and the
    connection cannot be immediately established; the connection will be
    established asynchronously
*   Errno::EINTR - the attempt to establish the connection was interrupted by
    delivery of a signal that was caught; the connection will be established
    asynchronously
*   Errno::EISCONN - the specified `socket` is already connected
*   Errno::EINVAL - the address length used for the *sockaddr* is not a valid
    length for the address family or there is an invalid family in *sockaddr*
*   Errno::ENAMETOOLONG - the pathname resolved had a length which exceeded
    PATH_MAX
*   Errno::ENETDOWN - the local interface used to reach the destination is
    down
*   Errno::ENETUNREACH - no route to the network is present
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOSR - there were insufficient STREAMS resources available to
    complete the operation
*   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
*   Errno::EOPNOTSUPP - the calling `socket` is listening and cannot be
    connected
*   Errno::EPROTOTYPE - the *sockaddr* has a different type than the socket
    bound to the specified peer address
*   Errno::ETIMEDOUT - the attempt to connect timed out before a connection
    was made.

On unix-based systems if the address family of the calling `socket` is AF_UNIX
the follow exceptions may be raised if the call to *connect* fails:
*   Errno::EIO - an i/o error occurred while reading from or writing to the
    file system
*   Errno::ELOOP - too many symbolic links were encountered in translating the
    pathname in *sockaddr*
*   Errno::ENAMETOOLLONG - a component of a pathname exceeded NAME_MAX
    characters, or an entire pathname exceeded PATH_MAX characters
*   Errno::ENOENT - a component of the pathname does not name an existing file
    or the pathname is an empty string
*   Errno::ENOTDIR - a component of the path prefix of the pathname in
    *sockaddr* is not a directory

### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *connect* fails:
*   Errno::ENETDOWN - the network is down
*   Errno::EADDRINUSE - the socket's local address is already in use
*   Errno::EINTR - the socket was cancelled
*   Errno::EINPROGRESS - a blocking socket is in progress or the service
    provider is still processing a callback function. Or a nonblocking connect
    call is in progress on the `socket`.
*   Errno::EALREADY - see Errno::EINVAL
*   Errno::EADDRNOTAVAIL - the remote address is not a valid address, such as
    ADDR_ANY TODO check ADDRANY TO INADDR_ANY
*   Errno::EAFNOSUPPORT - addresses in the specified family cannot be used
    with with this `socket`
*   Errno::ECONNREFUSED - the target *sockaddr* was not listening for
    connections refused the connection request
*   Errno::EFAULT - the socket's internal address or address length parameter
    is too small or is not a valid part of the user space address
*   Errno::EINVAL - the `socket` is a listening socket
*   Errno::EISCONN - the `socket` is already connected
*   Errno::ENETUNREACH - the network cannot be reached from this host at this
    time
*   Errno::EHOSTUNREACH - no route to the network is present
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOTSOCK - the `socket` argument does not refer to a socket
*   Errno::ETIMEDOUT - the attempt to connect timed out before a connection
    was made.
*   Errno::EWOULDBLOCK - the socket is marked as nonblocking and the
    connection cannot be completed immediately
*   Errno::EACCES - the attempt to connect the datagram socket to the
    broadcast address failed

### See
*   connect manual pages on unix-based systems
*   connect function in Microsoft's Winsock functions reference

**@overload** [] 

## connect_nonblock(addr, exception:true) [](#method-i-connect_nonblock)
call-seq:
    socket.connect_nonblock(remote_sockaddr, [options]) => 0

Requests a connection to be made on the given `remote_sockaddr` after
O_NONBLOCK is set for the underlying file descriptor. Returns 0 if successful,
otherwise an exception is raised.

### Parameter
*   `remote_sockaddr` - the `struct` sockaddr contained in a string or
    Addrinfo object

### Example:
    # Pull down Google's web page
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(80, 'www.google.com')
    begin # emulate blocking connect
      socket.connect_nonblock(sockaddr)
    rescue IO::WaitWritable
      IO.select(nil, [socket]) # wait 3-way handshake completion
      begin
        socket.connect_nonblock(sockaddr) # check connection failure
      rescue Errno::EISCONN
      end
    end
    socket.write("GET / HTTP/1.0\r\n\r\n")
    results = socket.read

Refer to Socket#connect for the exceptions that may be thrown if the call to
*connect_nonblock* fails.

Socket#connect_nonblock may raise any error corresponding to connect(2)
failure, including Errno::EINPROGRESS.

If the exception is Errno::EINPROGRESS, it is extended by IO::WaitWritable. So
IO::WaitWritable can be used to rescue the exceptions for retrying
connect_nonblock.

By specifying a keyword argument *exception* to `false`, you can indicate that
connect_nonblock should not raise an IO::WaitWritable exception, but return
the symbol `:wait_writable` instead.

### See
*   Socket#connect

## initialize(*args) [](#method-i-initialize)
Creates a new socket object.

*domain* should be a communications domain such as: :INET, :INET6, :UNIX, etc.

*socktype* should be a socket type such as: :STREAM, :DGRAM, :RAW, etc.

*protocol* is optional and should be a protocol defined in the domain. If
protocol is not given, 0 is used internally.

    Socket.new(:INET, :STREAM) # TCP socket
    Socket.new(:INET, :DGRAM)  # UDP socket
    Socket.new(:UNIX, :STREAM) # UNIX stream socket
    Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket

**@overload** [] 

## ipv6only!() [](#method-i-ipv6only!)
enable the socket option IPV6_V6ONLY if IPV6_V6ONLY is available.

## listen(log) [](#method-i-listen)
Listens for connections, using the specified `int` as the backlog. A call to
*listen* only applies if the `socket` is of type SOCK_STREAM or
SOCK_SEQPACKET.

### Parameter
*   `backlog` - the maximum length of the queue for pending connections.

### Example 1
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )
    socket.listen( 5 )

### Example 2 (listening on an arbitrary port, unix-based systems only):
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    socket.listen( 1 )

### Unix-based Exceptions
On unix based systems the above will work because a new `sockaddr` struct is
created on the address ADDR_ANY, for an arbitrary port number as handed off by
the kernel. It will not work on Windows, because Windows requires that the
`socket` is bound by calling *bind* before it can *listen*.

If the *backlog* amount exceeds the implementation-dependent maximum queue
length, the implementation's maximum queue length will be used.

On unix-based based systems the following system exceptions may be raised if
the call to *listen* fails:
*   Errno::EBADF - the *socket* argument is not a valid file descriptor
*   Errno::EDESTADDRREQ - the *socket* is not bound to a local address, and
    the protocol does not support listening on an unbound socket
*   Errno::EINVAL - the *socket* is already connected
*   Errno::ENOTSOCK - the *socket* argument does not refer to a socket
*   Errno::EOPNOTSUPP - the *socket* protocol does not support listen
*   Errno::EACCES - the calling process does not have appropriate privileges
*   Errno::EINVAL - the *socket* has been shut down
*   Errno::ENOBUFS - insufficient resources are available in the system to
    complete the call

### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *listen* fails:
*   Errno::ENETDOWN - the network is down
*   Errno::EADDRINUSE - the socket's local address is already in use. This
    usually occurs during the execution of *bind* but could be delayed if the
    call to *bind* was to a partially wildcard address (involving ADDR_ANY)
    and if a specific address needs to be committed at the time of the call to
    *listen*
*   Errno::EINPROGRESS - a Windows Sockets 1.1 call is in progress or the
    service provider is still processing a callback function
*   Errno::EINVAL - the `socket` has not been bound with a call to *bind*.
*   Errno::EISCONN - the `socket` is already connected
*   Errno::EMFILE - no more socket descriptors are available
*   Errno::ENOBUFS - no buffer space is available
*   Errno::ENOTSOC - `socket` is not a socket
*   Errno::EOPNOTSUPP - the referenced `socket` is not a type that supports
    the *listen* method

### See
*   listen manual pages on unix-based systems
*   listen function in Microsoft's Winsock functions reference

**@overload** [] 

## recvfrom(*args) [](#method-i-recvfrom)
Receives up to *maxlen* bytes from `socket`. *flags* is zero or more of the
`MSG_` options. The first element of the results, *mesg*, is the data
received. The second element, *sender_addrinfo*, contains protocol-specific
address information of the sender.

### Parameters
*   `maxlen` - the maximum number of bytes to receive from the socket
*   `flags` - zero or more of the `MSG_` options

### Example
    # In one file, start this first
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )
    socket.listen( 5 )
    client, client_addrinfo = socket.accept
    data = client.recvfrom( 20 )[0].chomp
    puts "I only received 20 bytes '#{data}'"
    sleep 1
    socket.close

    # In another file, start this second
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.connect( sockaddr )
    socket.puts "Watch this get cut short!"
    socket.close

### Unix-based Exceptions
On unix-based based systems the following system exceptions may be raised if
the call to *recvfrom* fails:
*   Errno::EAGAIN - the `socket` file descriptor is marked as O_NONBLOCK and
    no data is waiting to be received; or MSG_OOB is set and no out-of-band
    data is available and either the `socket` file descriptor is marked as
    O_NONBLOCK or the `socket` does not support blocking to wait for
    out-of-band-data
*   Errno::EWOULDBLOCK - see Errno::EAGAIN
*   Errno::EBADF - the `socket` is not a valid file descriptor
*   Errno::ECONNRESET - a connection was forcibly closed by a peer
*   Errno::EFAULT - the socket's internal buffer, address or address length
    cannot be accessed or written
*   Errno::EINTR - a signal interrupted *recvfrom* before any data was
    available
*   Errno::EINVAL - the MSG_OOB flag is set and no out-of-band data is
    available
*   Errno::EIO - an i/o error occurred while reading from or writing to the
    filesystem
*   Errno::ENOBUFS - insufficient resources were available in the system to
    perform the operation
*   Errno::ENOMEM - insufficient memory was available to fulfill the request
*   Errno::ENOSR - there were insufficient STREAMS resources available to
    complete the operation
*   Errno::ENOTCONN - a receive is attempted on a connection-mode socket that
    is not connected
*   Errno::ENOTSOCK - the `socket` does not refer to a socket
*   Errno::EOPNOTSUPP - the specified flags are not supported for this socket
    type
*   Errno::ETIMEDOUT - the connection timed out during connection
    establishment or due to a transmission timeout on an active connection

### Windows Exceptions
On Windows systems the following system exceptions may be raised if the call
to *recvfrom* fails:
*   Errno::ENETDOWN - the network is down
*   Errno::EFAULT - the internal buffer and from parameters on `socket` are
    not part of the user address space, or the internal fromlen parameter is
    too small to accommodate the peer address
*   Errno::EINTR - the (blocking) call was cancelled by an internal call to
    the WinSock function WSACancelBlockingCall
*   Errno::EINPROGRESS - a blocking Windows Sockets 1.1 call is in progress or
    the service provider is still processing a callback function
*   Errno::EINVAL - `socket` has not been bound with a call to *bind*, or an
    unknown flag was specified, or MSG_OOB was specified for a socket with
    SO_OOBINLINE enabled, or (for byte stream-style sockets only) the internal
    len parameter on `socket` was zero or negative
*   Errno::EISCONN - `socket` is already connected. The call to *recvfrom* is
    not permitted with a connected socket on a socket that is connection
    oriented or connectionless.
*   Errno::ENETRESET - the connection has been broken due to the keep-alive
    activity detecting a failure while the operation was in progress.
*   Errno::EOPNOTSUPP - MSG_OOB was specified, but `socket` is not
    stream-style such as type SOCK_STREAM. OOB data is not supported in the
    communication domain associated with `socket`, or `socket` is
    unidirectional and supports only send operations
*   Errno::ESHUTDOWN - `socket` has been shutdown. It is not possible to call
    *recvfrom* on a socket after *shutdown* has been invoked.
*   Errno::EWOULDBLOCK - `socket` is marked as nonblocking and a  call to
    *recvfrom* would block.
*   Errno::EMSGSIZE - the message was too large to fit into the specified
    buffer and was truncated.
*   Errno::ETIMEDOUT - the connection has been dropped, because of a network
    failure or because the system on the other end went down without notice
*   Errno::ECONNRESET - the virtual circuit was reset by the remote side
    executing a hard or abortive close. The application should close the
    socket; it is no longer usable. On a UDP-datagram socket this error
    indicates a previous send operation resulted in an ICMP Port Unreachable
    message.

**@overload** [] 

**@overload** [] 

## recvfrom_nonblock(len, flag0, strnil, exception:true) [](#method-i-recvfrom_nonblock)
call-seq:
    socket.recvfrom_nonblock(maxlen[, flags[, outbuf[, opts]]]) => [mesg, sender_addrinfo]

Receives up to *maxlen* bytes from `socket` using recvfrom(2) after O_NONBLOCK
is set for the underlying file descriptor. *flags* is zero or more of the
`MSG_` options. The first element of the results, *mesg*, is the data
received. The second element, *sender_addrinfo*, contains protocol-specific
address information of the sender.

When recvfrom(2) returns 0, Socket#recv_nonblock returns nil. In most cases it
means the connection was closed, but for UDP connections it may mean an empty
packet was received, as the underlying API makes it impossible to distinguish
these two cases.

### Parameters
*   `maxlen` - the maximum number of bytes to receive from the socket
*   `flags` - zero or more of the `MSG_` options
*   `outbuf` - destination String buffer
*   `opts` - keyword hash, supporting `exception: false`

### Example
    # In one file, start this first
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(2200, 'localhost')
    socket.bind(sockaddr)
    socket.listen(5)
    client, client_addrinfo = socket.accept
    begin # emulate blocking recvfrom
      pair = client.recvfrom_nonblock(20)
    rescue IO::WaitReadable
      IO.select([client])
      retry
    end
    data = pair[0].chomp
    puts "I only received 20 bytes '#{data}'"
    sleep 1
    socket.close

    # In another file, start this second
    require 'socket'
    include Socket::Constants
    socket = Socket.new(AF_INET, SOCK_STREAM, 0)
    sockaddr = Socket.sockaddr_in(2200, 'localhost')
    socket.connect(sockaddr)
    socket.puts "Watch this get cut short!"
    socket.close

Refer to Socket#recvfrom for the exceptions that may be thrown if the call to
*recvfrom_nonblock* fails.

Socket#recvfrom_nonblock may raise any error corresponding to recvfrom(2)
failure, including Errno::EWOULDBLOCK.

If the exception is Errno::EWOULDBLOCK or Errno::EAGAIN, it is extended by
IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for
retrying recvfrom_nonblock.

By specifying a keyword argument *exception* to `false`, you can indicate that
recvfrom_nonblock should not raise an IO::WaitReadable exception, but return
the symbol `:wait_readable` instead.

### See
*   Socket#recvfrom

## sysaccept() [](#method-i-sysaccept)
Accepts an incoming connection returning an array containing the (integer)
file descriptor for the incoming connection, *client_socket_fd*, and an
Addrinfo, *client_addrinfo*.

### Example
    # In one script, start this first
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.bind( sockaddr )
    socket.listen( 5 )
    client_fd, client_addrinfo = socket.sysaccept
    client_socket = Socket.for_fd( client_fd )
    puts "The client said, '#{client_socket.readline.chomp}'"
    client_socket.puts "Hello from script one!"
    socket.close

    # In another script, start this second
    require 'socket'
    include Socket::Constants
    socket = Socket.new( AF_INET, SOCK_STREAM, 0 )
    sockaddr = Socket.pack_sockaddr_in( 2200, 'localhost' )
    socket.connect( sockaddr )
    socket.puts "Hello from script 2."
    puts "The server said, '#{socket.readline.chomp}'"
    socket.close

Refer to Socket#accept for the exceptions that may be thrown if the call to
*sysaccept* fails.

### See
*   Socket#accept

**@overload** [] 

