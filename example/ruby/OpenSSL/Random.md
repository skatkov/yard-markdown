# Module: OpenSSL::Random
    



# Class Methods
## egd(filename ) [](#method-c-egd)
Same as ::egd_bytes but queries 255 bytes by default.
**@overload** [] 

## egd_bytes(filename , len ) [](#method-c-egd_bytes)
Queries the entropy gathering daemon EGD on socket path given by *filename*.

Fetches *length* number of bytes and uses ::add to seed the OpenSSL built-in
PRNG.
**@overload** [] 

## load_random_file(filename ) [](#method-c-load_random_file)
Reads bytes from *filename* and adds them to the PRNG.
**@overload** [] 

## random_add(str , entropy ) [](#method-c-random_add)
Mixes the bytes from *str* into the Pseudo Random Number Generator(PRNG)
state.

Thus, if the data from *str* are unpredictable to an adversary, this increases
the uncertainty about the state and makes the PRNG output less predictable.

The *entropy* argument is (the lower bound of) an estimate of how much
randomness is contained in *str*, measured in bytes.

### Example

    pid = $$
    now = Time.now
    ary = [now.to_i, now.nsec, 1000, pid]
    OpenSSL::Random.add(ary.join, 0.0)
    OpenSSL::Random.seed(ary.join)
**@overload** [] 

## random_bytes(len ) [](#method-c-random_bytes)
random_bytes(length) -> string

Generates a String with *length* number of cryptographically strong
pseudo-random bytes.

### Example

    OpenSSL::Random.random_bytes(12)
    #=> "..."
## seed(str ) [](#method-c-seed)
::seed is equivalent to ::add where *entropy* is length of *str*.
**@overload** [] 

## status?() [](#method-c-status?)
Return `true` if the PRNG has been seeded with enough data, `false` otherwise.
**@overload** [] 

**@return** [Boolean] 

## write_random_file(filename ) [](#method-c-write_random_file)
Writes a number of random generated bytes (currently 1024) to *filename* which
can be used to initialize the PRNG by calling ::load_random_file in a later
session.
**@overload** [] 


